'use strict';
import * as DAO from './../../common/dao';
import Blogs from './../model';
import UserGroups from './../../user-groups/model';
import schemas from './schemas';
import _ from 'lodash';
import * as errors from './../../common/errors';
import Bluebird from 'bluebird';
import * as utils from './../../common/utils';
class Posts {
    constructor(attrs) {
        _.assign(this, attrs);
        Object.defineProperty(this, 'audit', {
            writable: true,
            enumerable: false
        });
    }

    static newObject(doc, by) {
        let blog = doc.pre.blogs;
        _.merge(doc.payload, _.pick(blog, ['access', 'allowComments', 'needsReview']));
        if (doc.payload.state === 'published') {
            if (doc.payload.needsReview && !(blog.isPresentInOwners(by) || by === 'root')) {
                doc.payload.state = 'pending review';
            }
        }
        return Posts.create(blog._id,
            utils.org(doc),
            doc.payload.title,
            doc.payload.state,
            doc.payload.access,
            doc.payload.allowComments,
            doc.payload.needsReview,
            doc.payload.category,
            doc.payload.tags,
            doc.payload.attachments,
            doc.payload.contentType || 'post',
            doc.payload.content,
            by)
            .then((post) => {
                post.blog = blog;
                return post;
            });
    }

    static create(blogId, organisation, title, state, access, allowComments, needsReview, category, tags, attachments, contentType, content, by) {
        let now = new Date();
        let document = {
            blogId,
            organisation,
            title,
            state,
            access,
            allowComments,
            needsReview,
            category,
            tags,
            attachments,
            contentType,
            content,
            publishedBy: by,
            publishedOn: state === 'published' ? now : null,
            reviewedBy: state === 'published' ? by : null,
            reviewedOn: state === 'published' ? now : null
        };
        return Posts.insertAndAudit(document, by);
    }

    update(doc, by) {
        if (this.state !== 'archived') {
            return this.updatePost(doc, by);
        } else {
            return Bluebird.reject(new errors.ArchivedPostUpdateError());
        }
    }

    publish(doc, by) {
        if (['draft', 'pending review'].indexOf(this.state) !== -1) {
            let blog = doc.pre.blogs;
            if (this.needsReview && !(by === 'root' || blog.isPresentInOwners(by))) {
                this.setState('pending review', by);
            } else {
                this.setState('published', by);
                this.reviewedBy = by;
                this.reviewedOn = this.publishedOn = new Date();
            }
        }
        return this;
    }

    reject(doc, by) {
        if (['draft', 'pending review'].indexOf(this.state) !== -1) {
            this.setState('do not publish', by);
            this.reviewedBy = by;
            this.reviewedOn = new Date();
        }
        return this;
    }

    populate(user) {
        return Blogs.findOne({_id: Blogs.ObjectID(this.blogId)})
            .then((blog) => {
                this.blog = blog;
                return {canSee: this.access === 'public', blog: this.blog};
            })
            .then((res) => res.canSee ? res : res.blog)
            .then((blog) =>
                blog.canSee ?
                    blog : {
                    canSee: blog.access === 'public' ||
                    blog.isPresentInOwners(user.email) ||
                    blog.isPresentInContributors(user.email) ||
                    blog.isPresentInSubscribers(user.email),
                    blog: blog
                })
            .then((res) =>
                res.canSee ?
                    res.canSee :
                    UserGroups.count({
                        members: user.email,
                        organisation: user.organisation,
                        name: {$in: res.blog.subscriberGroups}
                    }).then((count) => count > 0))
            .then((canSee) => {
                if (!canSee) {
                    this.content = 'restricted because you are not an owner, contributor or subscriber to this blog and it is not a public post';
                }
                return this;
            });
    }
}
DAO.build(Posts, schemas);
export default Posts;
