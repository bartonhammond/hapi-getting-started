'use strict';
import _ from 'lodash';
import * as utils from './utils';
import config from './../config';
let i18n = config.i18n;
function propDescriptors(properties) {
    return properties.map((p) => {
        return {
            name: p,
            path: p.split('.'),
            method: 'set' + p.split('.').map(_.capitalize).join('')
        };
    });
}
function arrDescriptors(lists = []) {
    return lists.map((l) => {
        let methodSuffix = l.split('.').map(_.capitalize).join('');
        let pathadd = l.split('.');
        pathadd[pathadd.length - 1] = 'added' + _.capitalize(pathadd[pathadd.length - 1]);
        let pathrem = l.split('.');
        pathrem[pathrem.length - 1] = 'removed' + _.capitalize(pathrem[pathrem.length - 1]);
        return {
            name: l,
            path: l.split('.'),
            methodSuffix: methodSuffix,
            added: pathadd,
            addMethod: 'add' + methodSuffix,
            removed: pathrem,
            removeMethod: 'remove' + methodSuffix
        };
    });
}
class ModelBuilder {
    constructor(model) {
        this.model = model;
    }

    extendVirtualModel(fromVirtualModel) {
        _.extend(this.model, _.omit(fromVirtualModel, ['schema', 'create']));
        _.extend(this.model.prototype, fromVirtualModel.prototype);
        return this;
    }

    decorateWithSave() {
        let model = this.model;
        _.extend(this.model.prototype, {
            save() {
                return model.saveChangeHistory(this.audit)
                    .then(() => {
                        this.audit = undefined;
                        return model.upsert(this);
                    });
            }
        });
        return this;
    }

    decorateWithTrackChanges(idToUse = '_id') {
        let type = this.model.collection;
        _.extend(this.model.prototype, {
            trackChanges(action, origValues, newValues, by) {
                this.audit = this.audit || {
                        objectChangedType: type,
                        objectChangedId: this[idToUse],
                        organisation: this.organisation,
                        change: []
                    };
                this.audit.change.push({action, origValues, newValues});
                this.updatedBy = this.audit.by = by;
                this.updatedOn = this.audit.on = new Date();
                return this;
            }
        });
        return this;
    }

    decorateWithSoftDeletes() {
        _.extend(this.model.prototype, {
            del(doc, by) {
                return this.deactivate(by);
            },
            deactivate(by) {
                return this.setIsActive(false, by);
            },
            reactivate(by) {
                return this.setIsActive(true, by);
            }
        });
        return this;
    }

    decorateWithI18N(fields) {
        _.extend(this.model.prototype, {
            i18n(locale) {
                fields.forEach((field) => {
                    if (_.isArray(this[field]) && this[field].length === 2) {
                        this[field] = i18n.__({phrase: this[field][0], locale}, this[field][1]);
                    }
                }, this);
                return this;
            }
        });
        return this;
    }

    decorateWithSetMethods(properties) {
        properties.forEach((p) => {
            let {method, path, name} = p;
            _.extend(this.model.prototype, {
                [method](newValue, by) {
                    let origval = _.get(this, path);
                    if (!_.isUndefined(newValue) && !_.isEqual(origval, newValue)) {
                        this.trackChanges(name, origval, newValue, by);
                        _.set(this, path, newValue);
                    }
                    return this;
                }
            });
        }, this);
        return this;
    }

    decorateWithArrMethods(lists) {
        lists.forEach((role) => {
            let {path, name, methodSuffix, addMethod, removeMethod} = role;
            let isPresentIn = 'isPresentIn' + methodSuffix;
            _.extend(this.model.prototype, {
                [isPresentIn](toCheck) {
                    return !!_.find(_.get(this, path), (item) => _.isEqual(item, toCheck));
                },
                [addMethod](toAdd, by) {
                    let list = _.get(this, path);
                    toAdd.forEach((memberToAdd) => {
                        let found = _.find(list, (item) => _.isEqual(item, memberToAdd));
                        if (!found) {
                            list.push(memberToAdd);
                            this.trackChanges('add ' + name, null, memberToAdd, by);
                        }
                    }, this);
                    return this;
                },
                [removeMethod](toRemove, by) {
                    let list = _.get(this, path);
                    toRemove.forEach((memberToRemove) => {
                        let removed = _.remove(list, (item) => _.isEqual(item, memberToRemove));
                        if (utils.hasItems(removed)) {
                            this.trackChanges('remove ' + name, memberToRemove, null, by);
                        }
                    }, this);
                    return this;
                }
            });
        }, this);
        return this;
    }

    decorateWithUpdate(props, arrs, updateMethod) {
        _.extend(this.model.prototype, {
            [updateMethod](doc, by) {
                props.forEach((p) => {
                    let u = _.get(doc.payload, p.path);
                    if (!_.isUndefined(u)) {
                        this[p.method](u, by);
                    }
                }, this);
                arrs.forEach((arr) => {
                    let r = _.get(doc.payload, arr.removed);
                    if (!_.isUndefined(r) && utils.hasItems(r)) {
                        this[arr.removeMethod](r, by);
                    }
                    let a = _.get(doc.payload, arr.added);
                    if (!_.isUndefined(a) && utils.hasItems(a)) {
                        this[arr.addMethod](a, by);
                    }
                }, this);
                return this;
            }
        });
        return this;
    }

    decorateWithUpdates(properties, lists = [], updateMethod = 'update') {
        let props = propDescriptors(properties);
        let arrs = arrDescriptors(lists);
        this.decorateWithSetMethods(props);
        this.decorateWithArrMethods(arrs);
        this.decorateWithUpdate(props, arrs, updateMethod);
        return this;
    }

    decorateWithApproveRejectJoinLeave(affectedRole, needsApproval) {
        let needsApprovalMethodSuffix = needsApproval.split('.').map(_.capitalize).join('');
        let affectedRoleMethodSuffix = affectedRole.split('.').map(_.capitalize).join('');
        let toAdd = affectedRole.split('.');
        toAdd[toAdd.length - 1] = 'added' + _.capitalize(toAdd[toAdd.length - 1]);
        _.extend(this.model.prototype, {
            join(doc, by) {
                let method = this.access === 'public' ? affectedRoleMethodSuffix : needsApprovalMethodSuffix;
                return this['add' + method]([by], by);
            },
            approve(doc, by) {
                this['add' + affectedRoleMethodSuffix](_.get(doc.payload, toAdd), by);
                this['remove' + needsApprovalMethodSuffix](_.get(doc.payload, toAdd), by);
                return this;
            },
            reject(doc, by) {
                return this['remove' + needsApprovalMethodSuffix](_.get(doc.payload, toAdd), by);
            },
            leave(doc, by) {
                return this['remove' + affectedRoleMethodSuffix]([by], by);
            }
        });
        return this;
    }

    doneConfiguring() {
        return this.model;
    }
}

export default function buildModel(model, idForAudit = '_id') {
    let builder = new ModelBuilder(model);
    builder.decorateWithSave();
    builder.decorateWithSoftDeletes();
    builder.decorateWithTrackChanges(idForAudit);
    return builder;
}

export function buildVirtualModel(model) {
    return new ModelBuilder(model);
}
