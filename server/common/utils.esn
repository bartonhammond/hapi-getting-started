'use strict';
import {sortBy, keys, get, isArray} from 'lodash';
import moment from 'moment';
import bcrypt from 'bcrypt';
import boom from 'boom';
import {logger, statsd} from './../config';
import {ObjectID as objectID} from 'mongodb';
export function logAndBoom(err, reply) {
    logger.error({error: err, stack: err.stack});
    reply(err.canMakeBoomError ? err : boom.badImplementation(err));
}
export function toStatsD(route, statusCode, user, device, browser, start, finish) {
    statsd.increment([device, browser, route, route + statusCode, user], 1);
    statsd.timing([route, user], finish - start);
}
export function errback(err) {
    if (err) {
        logger.error({error: err, stack: err.stack});
    }
}
export function toStatsD2(bucket, query, start, err) {
    statsd.timing(bucket, Date.now() - start);
    if (query) {
        statsd.increment(bucket + '.' + sortBy(keys(query), String).join(','), 1);
    }
    if (err) {
        statsd.increment(bucket + '.err', 1);
    }
}
export function defaultcb(bucket, resolve, reject, query) {
    const start = Date.now();
    return (err, res) => {
        if (err) {
            logger.error({error: err, stack: err.stack});
            reject(err);
            toStatsD2(bucket, query, start, err);
        } else {
            resolve(res);
            toStatsD2(bucket, query, start);
        }
    };
}
export function ip(request) {
    return request.info.remoteAddress === '' ? 'test' : request.info.remoteAddress;
}
export function by(request) {
    return request.auth.credentials ? request.auth.credentials.user.email : 'notloggedin';
}
export function org(request) {
    return request.auth.credentials ? request.auth.credentials.user.organisation : '';
}
export function user(request) {
    return request.auth.credentials ? request.auth.credentials.user : undefined;
}
export function locale(request) {
    return get(request, ['auth', 'credentials', 'user', 'preferences', 'locale'], 'en');
}
// TODO: if not found in user prefs, figure out from request headers - tbd
export function lookupParamsOrPayloadOrQuery(request, field) {
    return request.params && request.params[field] ?
        request.params[field] :
        request.payload && request.payload[field] ?
            request.payload[field] :
            request.query && request.query[field] ?
                request.query[field] :
                undefined;
}
export function hasItems(arr) {
    return arr && arr.length > 0;
}
let queryBuilderForArray = {
    objectId: p => {
        return {$in: p.map((op) => objectID(op))};
    },
    exact: p => {
        return {$in: p};
    },
    partial: p => {
        return {$in: p.map((op) => new RegExp('^.*?' + op + '.*$', 'i'))};
    }
};
let queryBuilderForOne = {
    objectId: p => objectID(p),
    exact: p => p,
    partial: p => {
        return {$regex: new RegExp('^.*?' + p + '.*$', 'i')};
    }
};
export function buildQueryFor(type, query, request, fields) {
    let builder = queryBuilderForOne[type];
    let arrBuilder = queryBuilderForArray[type];
    fields.forEach(pair => {
        let p = lookupParamsOrPayloadOrQuery(request, pair[0]);
        if (p) {
            query[pair[1]] = isArray(p) ? arrBuilder(p) : builder(p);
        }
    });
    return query;
}
export function buildQueryForIDMatch(query, request, fields) {
    return buildQueryFor('objectId', query, request, fields);
}
export function buildQueryForExactMatch(query, request, fields) {
    return buildQueryFor('exact', query, request, fields);
}
export function buildQueryForPartialMatch(query, request, fields) {
    return buildQueryFor('partial', query, request, fields);
}
export function buildQueryForDateRange(query, request, field) {
    let pb4 = lookupParamsOrPayloadOrQuery(request, field + 'Before');
    if (pb4) {
        query[field] = {
            $lte: moment(pb4).toDate()
        };
    }
    let paf = lookupParamsOrPayloadOrQuery(request, field + 'After');
    if (paf) {
        query[field] = query[field] || {};
        query[field].$gte = moment(paf).toDate();
    }
    return query;
}
export function secureHash(password) {
    return bcrypt.hashSync(password, 10);
}
export function secureCompare(password, hash) {
    return bcrypt.compareSync(password, hash) || password === hash;
}
